"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/order.api.ts":
/*!******************************!*\
  !*** ./src/lib/order.api.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   orderApi: function() { return /* binding */ orderApi; }\n/* harmony export */ });\n/* harmony import */ var _utils_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/auth */ \"(app-pages-browser)/./src/utils/auth.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// admin/src/lib/order.api.ts\n\n// ==================== CONFIGURATION ====================\nconst getBaseUrl = ()=>{\n    // Always provide a fallback for local development\n    const baseUrl = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:5000\";\n    // Validate the URL\n    if (!baseUrl.startsWith(\"http\")) {\n        console.error(\"âŒ Invalid API URL:\", baseUrl);\n        return \"http://localhost:5000\"; // Fallback to localhost\n    }\n    return baseUrl;\n};\nconst API_BASE = getBaseUrl();\nconst API_URL = \"\".concat(API_BASE, \"/api\");\n// ==================== API UTILS ====================\nconst handleApiResponse = async (response)=>{\n    if (!response.ok) {\n        let errorMessage = \"API Error: \".concat(response.status, \" \").concat(response.statusText);\n        try {\n            const errorData = await response.json();\n            errorMessage = errorData.message || errorMessage;\n        } catch (e) {\n        // If response is not JSON, use status text\n        }\n        throw new Error(errorMessage);\n    }\n    return response.json();\n};\nconst fetchWithAuth = async function(url) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const authHeaders = (0,_utils_auth__WEBPACK_IMPORTED_MODULE_0__.getAuthHeaders)();\n    const config = {\n        ...options,\n        headers: {\n            ...authHeaders,\n            ...options.headers\n        },\n        credentials: \"include\"\n    };\n    try {\n        const response = await fetch(url, config);\n        return await handleApiResponse(response);\n    } catch (error) {\n        console.error(\"API call failed for \".concat(url, \":\"), error);\n        throw error;\n    }\n};\n// ==================== ORDER API ====================\nconst orderApi = {\n    // Get all orders\n    getOrders: async (params)=>{\n        const queryParams = new URLSearchParams();\n        if (params === null || params === void 0 ? void 0 : params.status) queryParams.append(\"status\", params.status);\n        if (params === null || params === void 0 ? void 0 : params.paymentStatus) queryParams.append(\"paymentStatus\", params.paymentStatus);\n        if (params === null || params === void 0 ? void 0 : params.search) queryParams.append(\"search\", params.search);\n        if (params === null || params === void 0 ? void 0 : params.page) queryParams.append(\"page\", params.page.toString());\n        if (params === null || params === void 0 ? void 0 : params.limit) queryParams.append(\"limit\", params.limit.toString());\n        if (params === null || params === void 0 ? void 0 : params.sortBy) queryParams.append(\"sortBy\", params.sortBy);\n        if (params === null || params === void 0 ? void 0 : params.sortOrder) queryParams.append(\"sortOrder\", params.sortOrder);\n        const url = \"\".concat(API_URL, \"/orders\").concat(queryParams.toString() ? \"?\".concat(queryParams.toString()) : \"\");\n        return fetchWithAuth(url);\n    },\n    // Get order by ID\n    getOrder: async (id)=>{\n        const url = \"\".concat(API_URL, \"/orders/\").concat(id);\n        return fetchWithAuth(url);\n    },\n    // Get order stats\n    getOrderStats: async (params)=>{\n        const queryParams = new URLSearchParams();\n        if (params === null || params === void 0 ? void 0 : params.startDate) queryParams.append(\"startDate\", params.startDate);\n        if (params === null || params === void 0 ? void 0 : params.endDate) queryParams.append(\"endDate\", params.endDate);\n        const queryString = queryParams.toString() ? \"?\".concat(queryParams.toString()) : \"\";\n        const url = \"\".concat(API_URL, \"/orders/stats\").concat(queryString);\n        return fetchWithAuth(url);\n    },\n    // Update order status\n    updateOrderStatus: async (id, data)=>{\n        const url = \"\".concat(API_URL, \"/orders/\").concat(id, \"/status\");\n        return fetchWithAuth(url, {\n            method: \"PUT\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n    },\n    // Update payment status\n    updatePaymentStatus: async (id, paymentStatus)=>{\n        const url = \"\".concat(API_URL, \"/orders/\").concat(id, \"/payment-status\");\n        return fetchWithAuth(url, {\n            method: \"PUT\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                paymentStatus\n            })\n        });\n    },\n    // Delete order\n    deleteOrder: async (id)=>{\n        const url = \"\".concat(API_URL, \"/orders/\").concat(id);\n        return fetchWithAuth(url, {\n            method: \"DELETE\"\n        });\n    }\n};\n// ==================== ENVIRONMENT SETUP ====================\n// Log the API configuration (only in development)\nif (true) {\n    console.log(\"\\uD83D\\uDD27 API Configuration:\", {\n        baseUrl: API_BASE,\n        apiUrl: API_URL,\n        environment: \"development\"\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBcUJxQixPQUFsQmpDLFNBQVEsWUFBYSxPQUFIaUM7UUFFakMsT0FBT3RCLGNBQWNDLEtBQUs7WUFDeEI0QixRQUFRO1FBQ1Y7SUFDRjtBQUNGLEVBQUU7QUFFRiw4REFBOEQ7QUFDOUQsa0RBQWtEO0FBQ2xELElBQUkvQyxJQUF5QixFQUFlO0lBQzFDSSxRQUFRaUQsR0FBRyxDQUFDLG1DQUF5QjtRQUNuQ3RELFNBQVNPO1FBQ1RnRCxRQUFRL0M7UUFDUmdELGFBOUpKO0lBK0pFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9vcmRlci5hcGkudHM/NWRiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBhZG1pbi9zcmMvbGliL29yZGVyLmFwaS50c1xyXG5cclxuaW1wb3J0IHsgZ2V0QXV0aEhlYWRlcnMgfSBmcm9tIFwiLi4vdXRpbHMvYXV0aFwiO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT0gQ09ORklHVVJBVElPTiA9PT09PT09PT09PT09PT09PT09PVxyXG5jb25zdCBnZXRCYXNlVXJsID0gKCkgPT4ge1xyXG4gIC8vIEFsd2F5cyBwcm92aWRlIGEgZmFsbGJhY2sgZm9yIGxvY2FsIGRldmVsb3BtZW50XHJcbiAgY29uc3QgYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjUwMDBcIjtcclxuICBcclxuICAvLyBWYWxpZGF0ZSB0aGUgVVJMXHJcbiAgaWYgKCFiYXNlVXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIEludmFsaWQgQVBJIFVSTDonLCBiYXNlVXJsKTtcclxuICAgIHJldHVybiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMFwiOyAvLyBGYWxsYmFjayB0byBsb2NhbGhvc3RcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGJhc2VVcmw7XHJcbn07XHJcblxyXG5jb25zdCBBUElfQkFTRSA9IGdldEJhc2VVcmwoKTtcclxuY29uc3QgQVBJX1VSTCA9IGAke0FQSV9CQVNFfS9hcGlgO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT0gQVBJIFVUSUxTID09PT09PT09PT09PT09PT09PT09XHJcbmNvbnN0IGhhbmRsZUFwaVJlc3BvbnNlID0gYXN5bmMgKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4ge1xyXG4gIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JNZXNzYWdlO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIC8vIElmIHJlc3BvbnNlIGlzIG5vdCBKU09OLCB1c2Ugc3RhdHVzIHRleHRcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbn07XHJcblxyXG5jb25zdCBmZXRjaFdpdGhBdXRoID0gYXN5bmMgKHVybDogc3RyaW5nLCBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9KSA9PiB7XHJcbiAgY29uc3QgYXV0aEhlYWRlcnMgPSBnZXRBdXRoSGVhZGVycygpO1xyXG4gIFxyXG4gIGNvbnN0IGNvbmZpZzogUmVxdWVzdEluaXQgPSB7XHJcbiAgICAuLi5vcHRpb25zLFxyXG4gICAgaGVhZGVyczoge1xyXG4gICAgICAuLi5hdXRoSGVhZGVycyxcclxuICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxyXG4gICAgfSxcclxuICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIiBhcyBSZXF1ZXN0Q3JlZGVudGlhbHMsXHJcbiAgfTtcclxuICBcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIGNvbmZpZyk7XHJcbiAgICByZXR1cm4gYXdhaXQgaGFuZGxlQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGBBUEkgY2FsbCBmYWlsZWQgZm9yICR7dXJsfTpgLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PSBPUkRFUiBBUEkgPT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGNvbnN0IG9yZGVyQXBpID0ge1xyXG4gIC8vIEdldCBhbGwgb3JkZXJzXHJcbiAgZ2V0T3JkZXJzOiBhc3luYyAocGFyYW1zPzoge1xyXG4gICAgc3RhdHVzPzogc3RyaW5nO1xyXG4gICAgcGF5bWVudFN0YXR1cz86IHN0cmluZztcclxuICAgIHNlYXJjaD86IHN0cmluZztcclxuICAgIHBhZ2U/OiBudW1iZXI7XHJcbiAgICBsaW1pdD86IG51bWJlcjtcclxuICAgIHNvcnRCeT86IHN0cmluZztcclxuICAgIHNvcnRPcmRlcj86IHN0cmluZztcclxuICB9KSA9PiB7XHJcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcclxuICAgIFxyXG4gICAgaWYgKHBhcmFtcz8uc3RhdHVzKSBxdWVyeVBhcmFtcy5hcHBlbmQoXCJzdGF0dXNcIiwgcGFyYW1zLnN0YXR1cyk7XHJcbiAgICBpZiAocGFyYW1zPy5wYXltZW50U3RhdHVzKSBxdWVyeVBhcmFtcy5hcHBlbmQoXCJwYXltZW50U3RhdHVzXCIsIHBhcmFtcy5wYXltZW50U3RhdHVzKTtcclxuICAgIGlmIChwYXJhbXM/LnNlYXJjaCkgcXVlcnlQYXJhbXMuYXBwZW5kKFwic2VhcmNoXCIsIHBhcmFtcy5zZWFyY2gpO1xyXG4gICAgaWYgKHBhcmFtcz8ucGFnZSkgcXVlcnlQYXJhbXMuYXBwZW5kKFwicGFnZVwiLCBwYXJhbXMucGFnZS50b1N0cmluZygpKTtcclxuICAgIGlmIChwYXJhbXM/LmxpbWl0KSBxdWVyeVBhcmFtcy5hcHBlbmQoXCJsaW1pdFwiLCBwYXJhbXMubGltaXQudG9TdHJpbmcoKSk7XHJcbiAgICBpZiAocGFyYW1zPy5zb3J0QnkpIHF1ZXJ5UGFyYW1zLmFwcGVuZChcInNvcnRCeVwiLCBwYXJhbXMuc29ydEJ5KTtcclxuICAgIGlmIChwYXJhbXM/LnNvcnRPcmRlcikgcXVlcnlQYXJhbXMuYXBwZW5kKFwic29ydE9yZGVyXCIsIHBhcmFtcy5zb3J0T3JkZXIpO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGAke0FQSV9VUkx9L29yZGVycyR7cXVlcnlQYXJhbXMudG9TdHJpbmcoKSA/IGA/JHtxdWVyeVBhcmFtcy50b1N0cmluZygpfWAgOiAnJ31gO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZmV0Y2hXaXRoQXV0aCh1cmwpO1xyXG4gIH0sXHJcblxyXG4gIC8vIEdldCBvcmRlciBieSBJRFxyXG4gIGdldE9yZGVyOiBhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgdXJsID0gYCR7QVBJX1VSTH0vb3JkZXJzLyR7aWR9YDtcclxuICAgIHJldHVybiBmZXRjaFdpdGhBdXRoKHVybCk7XHJcbiAgfSxcclxuXHJcbiAgLy8gR2V0IG9yZGVyIHN0YXRzXHJcbiAgZ2V0T3JkZXJTdGF0czogYXN5bmMgKHBhcmFtcz86IHsgXHJcbiAgICBzdGFydERhdGU/OiBzdHJpbmc7IFxyXG4gICAgZW5kRGF0ZT86IHN0cmluZztcclxuICB9KSA9PiB7XHJcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcclxuICAgIFxyXG4gICAgaWYgKHBhcmFtcz8uc3RhcnREYXRlKSBxdWVyeVBhcmFtcy5hcHBlbmQoXCJzdGFydERhdGVcIiwgcGFyYW1zLnN0YXJ0RGF0ZSk7XHJcbiAgICBpZiAocGFyYW1zPy5lbmREYXRlKSBxdWVyeVBhcmFtcy5hcHBlbmQoXCJlbmREYXRlXCIsIHBhcmFtcy5lbmREYXRlKTtcclxuXHJcbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IHF1ZXJ5UGFyYW1zLnRvU3RyaW5nKCkgPyBgPyR7cXVlcnlQYXJhbXMudG9TdHJpbmcoKX1gIDogJyc7XHJcbiAgICBjb25zdCB1cmwgPSBgJHtBUElfVVJMfS9vcmRlcnMvc3RhdHMke3F1ZXJ5U3RyaW5nfWA7XHJcbiAgICBcclxuICAgIHJldHVybiBmZXRjaFdpdGhBdXRoKHVybCk7XHJcbiAgfSxcclxuXHJcbiAgLy8gVXBkYXRlIG9yZGVyIHN0YXR1c1xyXG4gIHVwZGF0ZU9yZGVyU3RhdHVzOiBhc3luYyAoXHJcbiAgICBpZDogc3RyaW5nLFxyXG4gICAgZGF0YToge1xyXG4gICAgICBzdGF0dXM6IHN0cmluZztcclxuICAgICAgbm90ZXM/OiBzdHJpbmc7XHJcbiAgICAgIHRyYWNraW5nTnVtYmVyPzogc3RyaW5nO1xyXG4gICAgfVxyXG4gICkgPT4ge1xyXG4gICAgY29uc3QgdXJsID0gYCR7QVBJX1VSTH0vb3JkZXJzLyR7aWR9L3N0YXR1c2A7XHJcbiAgICBcclxuICAgIHJldHVybiBmZXRjaFdpdGhBdXRoKHVybCwge1xyXG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICAvLyBVcGRhdGUgcGF5bWVudCBzdGF0dXNcclxuICB1cGRhdGVQYXltZW50U3RhdHVzOiBhc3luYyAoaWQ6IHN0cmluZywgcGF5bWVudFN0YXR1czogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCB1cmwgPSBgJHtBUElfVVJMfS9vcmRlcnMvJHtpZH0vcGF5bWVudC1zdGF0dXNgO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZmV0Y2hXaXRoQXV0aCh1cmwsIHtcclxuICAgICAgbWV0aG9kOiBcIlBVVFwiLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcGF5bWVudFN0YXR1cyB9KSxcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIC8vIERlbGV0ZSBvcmRlclxyXG4gIGRlbGV0ZU9yZGVyOiBhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgdXJsID0gYCR7QVBJX1VSTH0vb3JkZXJzLyR7aWR9YDtcclxuICAgIFxyXG4gICAgcmV0dXJuIGZldGNoV2l0aEF1dGgodXJsLCB7XHJcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcclxuICAgIH0pO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PSBFTlZJUk9OTUVOVCBTRVRVUCA9PT09PT09PT09PT09PT09PT09PVxyXG4vLyBMb2cgdGhlIEFQSSBjb25maWd1cmF0aW9uIChvbmx5IGluIGRldmVsb3BtZW50KVxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcclxuICBjb25zb2xlLmxvZygn8J+UpyBBUEkgQ29uZmlndXJhdGlvbjonLCB7XHJcbiAgICBiYXNlVXJsOiBBUElfQkFTRSxcclxuICAgIGFwaVVybDogQVBJX1VSTCxcclxuICAgIGVudmlyb25tZW50OiBwcm9jZXNzLmVudi5OT0RFX0VOVixcclxuICB9KTtcclxufSJdLCJuYW1lcyI6WyJnZXRBdXRoSGVhZGVycyIsImdldEJhc2VVcmwiLCJiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJzdGFydHNXaXRoIiwiY29uc29sZSIsImVycm9yIiwiQVBJX0JBU0UiLCJBUElfVVJMIiwiaGFuZGxlQXBpUmVzcG9uc2UiLCJyZXNwb25zZSIsIm9rIiwiZXJyb3JNZXNzYWdlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImVycm9yRGF0YSIsImpzb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJmZXRjaFdpdGhBdXRoIiwidXJsIiwib3B0aW9ucyIsImF1dGhIZWFkZXJzIiwiY29uZmlnIiwiaGVhZGVycyIsImNyZWRlbnRpYWxzIiwiZmV0Y2giLCJvcmRlckFwaSIsImdldE9yZGVycyIsInBhcmFtcyIsInF1ZXJ5UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwicGF5bWVudFN0YXR1cyIsInNlYXJjaCIsInBhZ2UiLCJ0b1N0cmluZyIsImxpbWl0Iiwic29ydEJ5Iiwic29ydE9yZGVyIiwiZ2V0T3JkZXIiLCJpZCIsImdldE9yZGVyU3RhdHMiLCJzdGFydERhdGUiLCJlbmREYXRlIiwicXVlcnlTdHJpbmciLCJ1cGRhdGVPcmRlclN0YXR1cyIsImRhdGEiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVwZGF0ZVBheW1lbnRTdGF0dXMiLCJkZWxldGVPcmRlciIsImxvZyIsImFwaVVybCIsImVudmlyb25tZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/order.api.ts\n"));

/***/ })

});